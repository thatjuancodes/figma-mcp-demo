// add a websocket server to connect to figma MCP server
import WebSocket, { WebSocketServer } from 'ws';
import 'dotenv/config';
import fetch from 'node-fetch';
import express from 'express';
import http from 'http';

// --- HTTP Server Setup with Express ---
const app = express();
const server = http.createServer(app);

// Middleware to parse JSON bodies
app.use(express.json({ limit: '50mb' }));

// --- WebSocket Server Setup (attached to HTTP server) ---
const wss = new WebSocketServer({ server });

wss.on('connection', function connection(ws) {
  console.log('Client connected to WebSocket');
  ws.on('message', function message(data) {
    const messageString = data.toString();
    console.log('WebSocket received: %s', messageString);
  });
  ws.on('close', () => {
    console.log('Client disconnected from WebSocket');
  });
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
});

async function fetchFigmaFile(fileKey) {
  console.log(`Fetching Figma file: ${fileKey} using token: ${process.env.FIGMA_API_TOKEN ? 'Present' : 'MISSING'}`);
  const response = await fetch(`https://api.figma.com/v1/files/${fileKey}`, {
    headers: {
      'X-Figma-Token': process.env.FIGMA_API_TOKEN,
    },
  });
  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`Figma API request failed: ${response.status} ${response.statusText} - ${errorBody}`);
  }
  return response.json();
}

const FIGMA_FILE_KEY = 'jWaq2LpehD8w3JFTorfXpz';

setInterval(async () => {
  try {
    const data = await fetchFigmaFile(FIGMA_FILE_KEY);
    const jsonData = JSON.stringify(data);
    wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(jsonData);
      }
    });
  } catch (error) {
    console.error('Error fetching or broadcasting Figma data:', error);
  }
}, 10000);

// --- Gemini API Integration (New Endpoint) ---
// Ensure you have @google/generative-ai installed: npm install @google/generative-ai
// import { GoogleGenerativeAI } from "@google/generative-ai";

// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

app.post('/api/generate-html', async (req, res) => {
  const figmaPageData = req.body;

  if (!figmaPageData) {
    return res.status(400).send('Error: No Figma page data received.');
  }

  console.log('Received Figma data for HTML generation on backend.');
  // console.log('Figma Page Data:', JSON.stringify(figmaPageData, null, 2)); // For debugging

  try {
    // TODO: Implement actual Gemini API call here
    // const model = genAI.getGenerativeModel({ model: "gemini-pro" }); // Or your preferred model
    // const prompt = `
    //   You are an expert web developer. Your task is to convert the provided Figma page JSON data
    //   into a single, well-structured HTML file.
    //   The Figma JSON includes nodes with types like 'RECTANGLE', 'TEXT', etc.
    //   Each node has an 'absoluteBoundingBox' (with x, y, width, height) for its position and size,
    //   and 'fills' for background colors (especially for RECTANGLEs). Text content is in 'characters'.
    //   Pay attention to text styles if available (e.g., node.style.fontSize).

    //   Figma Page Data:
    //   ${JSON.stringify(figmaPageData)}

    //   Generate only the HTML code as a raw string.
    //   Do not include any markdown formatting (like \`\`\`html) or explanatory text outside of the HTML itself.
    //   The HTML should try to replicate the layout and appearance described by the Figma data using
    //   inline styles for positioning (left, top, width, height, position: absolute) and
    //   background colors derived from the 'fills'.
    //   For TEXT nodes, use appropriate text tags.
    // `;

    // const result = await model.generateContent(prompt);
    // const response = await result.response;
    // const generatedHtml = response.text();

    // For now, sending a mock response:
    const mockGeneratedHtml = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Generated by Gemini (Mock)</title>
          <style>
              body { margin: 0; position: relative; font-family: sans-serif; }
              /* Basic styling for mock elements */
              .mock-element {
                  border: 1px dashed blue;
                  padding: 5px;
                  box-sizing: border-box;
                  position: absolute; /* Assuming Gemini will use absolute for layout */
              }
          </style>
      </head>
      <body>
          <h1>HTML for ${figmaPageData.name || 'Selected Page'} (Mock Response)</h1>
          <p>This is a mocked HTML response from the server. Replace this with the actual Gemini API call.</p>
          <div class="mock-element" style="left: 10px; top: 50px; width: 200px; height: 100px; background-color: lightblue;">
              Mock Element 1 (e.g., a Rectangle)
          </div>
          <div class="mock-element" style="left: 220px; top: 70px; width: 150px; height: 50px; background-color: lightgreen;">
              Mock Text Element
          </div>
          <p>Figma Page ID was: ${figmaPageData.id || 'N/A'}</p>
      </body>
      </html>
    `;
    console.log('Sending mock HTML response to client.');
    res.setHeader('Content-Type', 'text/html');
    res.send(mockGeneratedHtml);

  } catch (error) {
    console.error('Error calling Gemini API (or in mock setup):', error);
    res.status(500).send('Error generating HTML. Check server logs.');
  }
});

app.get('/test-backend-route', (req, res) => {
  console.log('GET /test-backend-route hit!');
  res.send('Backend GET route is working!');
});

// --- Start the Server ---
const PORT = process.env.PORT || 8080;
server.listen(PORT, () => {
  console.log(`HTTP server listening on port ${PORT}`);
  console.log(`WebSocket server is also attached and running.`);
});

// This part below from your original code seems to be an attempt to create a client
// within the server, which is usually not what you want for the main server logic.
// If you need to test the WebSocket server *from* the server, it should be done differently.
// Commenting it out to avoid confusion and potential issues.
// const ws = new WebSocket('ws://localhost:8080');
// ws.onmessage = (event) => console.log('Received:', event.data);


